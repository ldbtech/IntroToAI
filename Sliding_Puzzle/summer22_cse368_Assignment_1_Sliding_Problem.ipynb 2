{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "nAqowRnlIqOH"
   },
   "source": [
    "# Assignment 1 - Sliding Problem\n",
    "## <font color='red'>Checkpoint: </font>June 14, 11:59pm\n",
    "## <font color='red'>Due Date: </font>June 17, 11:59pm\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "PCAWwfjMJQTU"
   },
   "source": [
    "## 1. Defining 3x3 sliding problem environment\n",
    "No modification should be done in this part."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "kHRlSnfLE6kH"
   },
   "outputs": [],
   "source": [
    "import random\n",
    "import time\n",
    "\n",
    "class state:\n",
    "    \"\"\" State of sliding number puzzle\n",
    "        Contains array of values called 'board' to indicate\n",
    "        tile positions, and the position of tile '0', which\n",
    "        indicates the empty space on the board.         \"\"\"\n",
    "    \n",
    "    boardSize=3\n",
    "\n",
    "    def __init__(self,s=None):\n",
    "\n",
    "        if s == None:\n",
    "            \n",
    "            tiles=range(self.boardSize*self.boardSize).__iter__()\n",
    "            self.board=[[next(tiles) for i in range(self.boardSize)] for j in range(self.boardSize)]\n",
    "\n",
    "            #keep track of empty position\n",
    "            self.position=[0,0]\n",
    "        \n",
    "        else:\n",
    "            #copy the board\n",
    "            self.board=[]\n",
    "            for row in s.board:\n",
    "                self.board.append(list(row))\n",
    "\n",
    "            #copy the positions    \n",
    "            self.position=list(s.position)\n",
    "            \n",
    "        \n",
    "    def __str__(self):\n",
    "        rstr=''\n",
    "        for row in self.board:\n",
    "            rstr += str(row) + '\\n'\n",
    "        return rstr\n",
    "    \n",
    "    #overload to allow comparison of lists and states with ==\n",
    "    def __eq__(self,other):\n",
    "        if isinstance(other, state):\n",
    "            return self.board == other.board\n",
    "        else:\n",
    "            return NotImplemented"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "9Fn2W1mPdCSH"
   },
   "source": [
    "## 2. Defining nodes for search graph\n",
    "No modification should be done in this part."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "Eb7EKTX4dBdK"
   },
   "outputs": [],
   "source": [
    "class node:\n",
    "    \n",
    "    nodeCount=0\n",
    "    \n",
    "    def __init__(self, p, a, c, s):\n",
    "        \n",
    "        #keep track of how many nodes were created\n",
    "        self.__class__.nodeCount += 1    \n",
    "        self.nodeID=self.nodeCount\n",
    "        \n",
    "        self.parent=p\n",
    "        self.cost=c\n",
    "        self.action=a\n",
    "        self.state=s\n",
    "        \n",
    "    #test equivalence Should be state\n",
    "\n",
    "    def __str__(self):\n",
    "        rstr= 'NodeID: ' + str(self.nodeID) + '\\n'\n",
    "        if self.parent != None:\n",
    "            rstr+='Parent: ' + str(self.parent.nodeID) + '\\n'\n",
    "        if self.action != None:\n",
    "            rstr+='Action: ' + self.action  + '\\n'\n",
    "        rstr+='Cost:   ' + str(self.cost) + '\\n'\n",
    "        rstr+='State:\\n' + str(self.state)\n",
    "        return rstr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def childNode(n, action, problem):\n",
    "    return node(n,action, n.cost + 1, problem.apply(action,state(n.state)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "Vg408PhSdPYY"
   },
   "source": [
    "## 3. Defining problem\n",
    "No modification should be done in this part.\n",
    "\n",
    "Possible actions of our agents are \n",
    "* 'U' - Up\n",
    "* 'L' - Left\n",
    "* 'D' - Down\n",
    "* 'R' - Right\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "2Kto9WcUdP56"
   },
   "outputs": [],
   "source": [
    "#problem\n",
    "class problem:\n",
    "    \"\"\"Class that defines a search problem\"\"\"\n",
    "\n",
    "    def __init__(self):\n",
    "        self.actions=['U','L','D','R']\n",
    "        self.initialState=[[]]\n",
    "        self.goalState=[[]]\n",
    "\n",
    "    def apply(self,a,s):\n",
    "\n",
    "        #positions after move, still refers to s.position object\n",
    "        post=s.position\n",
    "\n",
    "        #make a copy\n",
    "        pre=list(post)\n",
    "        \n",
    "        #compute post position\n",
    "        if a == 'U':\n",
    "            post[0]=max(pre[0]-1,0)\n",
    "        elif a == 'L':            \n",
    "            post[1]=max(pre[1]-1,0)\n",
    "        elif a == 'D':\n",
    "            post[0]=min(pre[0]+1,s.boardSize-1)\n",
    "        elif a == 'R':\n",
    "            post[1]=min(pre[1]+1,s.boardSize-1)\n",
    "        else:\n",
    "            print('Undefined action: ' + str(a))\n",
    "            raise StandardError('Action not defined for this problem!')\n",
    "\n",
    "        #store the old tile\n",
    "        tile=s.board[pre[0]][pre[1]]\n",
    "        \n",
    "        s.board[pre[0]][pre[1]]=s.board[post[0]][post[1]]\n",
    "        s.board[post[0]][post[1]]=tile      \n",
    "\n",
    "        return s\n",
    "        \n",
    "    def applicable(self,s):\n",
    "        actionList=[]\n",
    "\n",
    "        #check if actions are applicable\n",
    "        #Not in top row\n",
    "        if s.position[0]>0:\n",
    "            actionList.append('U')\n",
    "\n",
    "        #not in left most col\n",
    "        if s.position[1]>0:\n",
    "            actionList.append('L')\n",
    "\n",
    "        #not in bottom row\n",
    "        if s.position[0]<(s.boardSize-1):\n",
    "            actionList.append('D')\n",
    "\n",
    "        #not in right col\n",
    "        if s.position[1]<(s.boardSize-1):\n",
    "            actionList.append('R')\n",
    "\n",
    "        return actionList\n",
    "\n",
    "    def goalTest(self,s):\n",
    "        return self.goalState==s     "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def applyRndMoves(numMoves,s,p):\n",
    "    for i in range(numMoves):\n",
    "        p.apply(p.actions[random.randint(0,3)],s)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "Sp8AfgeQNOcT"
   },
   "source": [
    "# Solving Sliding problem\n",
    "1.   Breadth First Search (BFS) Approach\n",
    "> *It will find the closest solution, by searching layer-by-layer.*\n",
    "\n",
    "> The BFS explores an entire layer before progressing.  Each layer consists of a list of nodes.  These lists are looped through, and expanded into a new list based on the available directions to explore for that node at it's given state.  Once a list is exhausted, it is replaced by the new list, and is then expanded.  The cycle ends once 15 layers, or 15 lists have been explored, or when a solution is found.  \n",
    "\n",
    "2.   Depth First Search (DFS) Approach\n",
    "> *It will find the first solution, by searching as deep as possible first.*\n",
    "\n",
    "> The DFS method explores as deeply as possible, before branching out to adjacent nodes.  This was accomplished using recurrence and a for loop.  The for loop would loop through all directions in a function, and call on the function to explore downwards in each one.  Once the function reached it's maximum depth of 15 without finding a solution, it would return \"None,\" allowing the previously halted function above it to explore a new, adjacent path, or return \"None\" itself to allow the function above it to explore a new path, etc.  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "NoXZnAysFhw3"
   },
   "outputs": [],
   "source": [
    "class Searches:    \n",
    "    \n",
    "    def BFS(self, problem):\n",
    "        #write your code here\n",
    "        path_cost = 0 \n",
    "        \n",
    "        n = node(p = None, s=problem.initialState, c=path_cost, a=None) # the parent with initial_State.\n",
    "                \n",
    "        if problem.goalTest(n.state): # if we already have init state==goal_state\n",
    "            return n\n",
    "        \n",
    "        frontier = []\n",
    "        frontier.append(n) # append the parent \n",
    "        \n",
    "        explored = []\n",
    "        while frontier:\n",
    "            n_ode = frontier.pop(0)\n",
    "            \n",
    "            if problem.goalTest(n_ode): # if we reach the solution then return it.\n",
    "                return n_ode\n",
    "            if n_ode.state not in explored:\n",
    "                explored.append(n_ode.state)   \n",
    "            \n",
    "            actions = problem.applicable(n_ode.state) #actions that need to be performed on the node\n",
    "            for a in actions:\n",
    "                child = childNode(n_ode, a, problem) # creation of children.\n",
    "                \n",
    "                if child not in frontier or child.state not in explored:\n",
    "                    if problem.goalTest(child.state):\n",
    "                        return child\n",
    "                    frontier.append(child)\n",
    "                    #explored.put(child.state)\n",
    "        return None\n",
    "             \n",
    "    def DFS(self, problem):\n",
    "        path_cost = 0 \n",
    "        parent = node(p = None, s=problem.initialState, c=path_cost, a=None)\n",
    "        if problem.goalTest(parent.state): # if we already have init state==goal_state\n",
    "            return parent\n",
    "        explored = []\n",
    "        return self.DFS_helper(problem, explored, parent)\n",
    "        \n",
    "    def DFS_helper(self, problem, explored, node):\n",
    "        if problem.goalTest(node.state): # base case\n",
    "            return node\n",
    "        explored.append(node.state)       \n",
    "\n",
    "        for a in problem.applicable(node.state):\n",
    "            child = childNode(node, a, problem)\n",
    "            \n",
    "            if child.state not in explored:\n",
    "                self.DFS_helper(problem, explored, child)\n",
    "                \n",
    "        \n",
    "        return None\n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "vmu0UGZ-QgM0"
   },
   "source": [
    "# Test your solution\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 595
    },
    "colab_type": "code",
    "id": "UkfJZ6HxQfhr",
    "outputId": "407a1b9c-b9a4-4820-99ae-8ac879b2c1cf"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Initial State \n",
      " [1, 2, 5]\n",
      "[3, 4, 8]\n",
      "[6, 0, 7]\n",
      "\n",
      "=== BFS  ===\n",
      "NodeID: 53176\n",
      "Parent: 53016\n",
      "Action: L\n",
      "Cost:   5\n",
      "State:\n",
      "[0, 1, 2]\n",
      "[3, 4, 5]\n",
      "[6, 7, 8]\n",
      "\n",
      "Time 0.0048269999999988045\n",
      "Explored Nodes: 53176\n",
      "Generating Random Position\n",
      "[0, 2, 5]\n",
      "[1, 3, 4]\n",
      "[6, 7, 8]\n",
      "\n",
      "=== BFS  ===\n",
      "NodeID: 53546\n",
      "Parent: 53306\n",
      "Action: L\n",
      "Cost:   6\n",
      "State:\n",
      "[0, 1, 2]\n",
      "[3, 4, 5]\n",
      "[6, 7, 8]\n",
      "\n",
      "Time 0.005651000000000295\n",
      "Explored Nodes: 53546\n",
      "\n",
      "\n",
      "################[DFS]###################\n",
      "[0, 2, 5]\n",
      "[1, 3, 4]\n",
      "[6, 7, 8]\n",
      "\n",
      "=== DFS  ===\n"
     ]
    },
    {
     "ename": "RecursionError",
     "evalue": "maximum recursion depth exceeded in comparison",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mRecursionError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m/var/folders/7y/n7y0qjq95bqc4cy4yvgcw6380000gn/T/ipykernel_14719/276163614.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     54\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'=== DFS  ==='\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     55\u001b[0m     \u001b[0mstartTime\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtime\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mprocess_time\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 56\u001b[0;31m     \u001b[0mres\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0msearch\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDFS\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mp\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     57\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mres\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     58\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Time \"\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtime\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mprocess_time\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0mstartTime\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/var/folders/7y/n7y0qjq95bqc4cy4yvgcw6380000gn/T/ipykernel_14719/3468767926.py\u001b[0m in \u001b[0;36mDFS\u001b[0;34m(self, problem)\u001b[0m\n\u001b[1;32m     39\u001b[0m             \u001b[0;32mreturn\u001b[0m \u001b[0mparent\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     40\u001b[0m         \u001b[0mexplored\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 41\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDFS_helper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mproblem\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mexplored\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mparent\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     42\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     43\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mDFS_helper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mproblem\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mexplored\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/var/folders/7y/n7y0qjq95bqc4cy4yvgcw6380000gn/T/ipykernel_14719/3468767926.py\u001b[0m in \u001b[0;36mDFS_helper\u001b[0;34m(self, problem, explored, node)\u001b[0m\n\u001b[1;32m     51\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     52\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mchild\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstate\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mexplored\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 53\u001b[0;31m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDFS_helper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mproblem\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mexplored\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mchild\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     54\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     55\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "... last 1 frames repeated, from the frame below ...\n",
      "\u001b[0;32m/var/folders/7y/n7y0qjq95bqc4cy4yvgcw6380000gn/T/ipykernel_14719/3468767926.py\u001b[0m in \u001b[0;36mDFS_helper\u001b[0;34m(self, problem, explored, node)\u001b[0m\n\u001b[1;32m     51\u001b[0m                 \u001b[0;32mreturn\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     52\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mchild\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstate\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mexplored\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 53\u001b[0;31m                 \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDFS_helper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mproblem\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mexplored\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mchild\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     54\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     55\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mRecursionError\u001b[0m: maximum recursion depth exceeded in comparison"
     ]
    }
   ],
   "source": [
    "if __name__ == '__main__':\n",
    "       \n",
    "    search = Searches()\n",
    "    \n",
    "    p = problem()\n",
    "    s = state()\n",
    "    \n",
    "    p.goalState = state(s)\n",
    "    \n",
    "    p.apply('R',s)\n",
    "    p.apply('R',s)\n",
    "    p.apply('D',s)\n",
    "    p.apply('D',s)\n",
    "    p.apply('L',s)\n",
    "    \n",
    "    p.initialState=state(s) \n",
    "    print(\"Initial State \\n\", p.initialState)    \n",
    "    \n",
    "## Uncomment for testing BFS solution\n",
    "\n",
    "    print('=== BFS  ===')\n",
    "    startTime=time.process_time()\n",
    "    res=search.BFS(p)\n",
    "    print(res)\n",
    "    print(\"Time \" + str(time.process_time()-startTime))\n",
    "    print(\"Explored Nodes: \"+ str(node.nodeCount))\n",
    " \n",
    "    \n",
    "    \n",
    "    print(\"Generating Random Position\")\n",
    "    si=state(s)\n",
    "    applyRndMoves(15,si,p)\n",
    "    p.initialState=si\n",
    "    print(si)\n",
    "    \n",
    "    startTime=time.process_time()\n",
    "    \n",
    "    print('=== BFS  ===')\n",
    "    startTime=time.process_time()\n",
    "    res=search.BFS(p)\n",
    "    print(res)\n",
    "    print(\"Time \" + str(time.process_time()-startTime))\n",
    "    print(\"Explored Nodes: \"+ str(node.nodeCount))\n",
    "\n",
    "    print(\"\\n\")\n",
    "    print(\"################[DFS]###################\")\n",
    "\n",
    "## Uncomment for testing DFS solution\n",
    "\n",
    "    \n",
    "    print(p.initialState)\n",
    "    \n",
    "    \n",
    "    print('=== DFS  ===')\n",
    "    startTime=time.process_time()\n",
    "    res=search.DFS(p)\n",
    "    print(res)\n",
    "    print(\"Time \" + str(time.process_time()-startTime))\n",
    "    print(\"Explored Nodes: \"+ str(node.nodeCount))\n",
    " \n",
    "    \n",
    "    \n",
    "    print(\"Generating Random Position\")\n",
    "    si = state(s)\n",
    "    applyRndMoves(15,si,p)\n",
    "    p.initialState=si\n",
    "    print(si)\n",
    "    \n",
    "    startTime = time.process_time()\n",
    "    \n",
    "    print('=== DFS  ===')\n",
    "    startTime=time.process_time()\n",
    "    res=search.DFS(p)\n",
    "    print(res)\n",
    "    print(\"Time \" + str(time.process_time()-startTime))\n",
    "    print(\"Explored Nodes: \"+ str(node.nodeCount))\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "n7jtnp1WzLKN"
   },
   "source": [
    "# Results\n",
    "For BFS it took about 0.001ms to find a goal which 3*3 matrix. values in order.\n",
    "However, DFS I used recursive method, it could not converge into optimal solution due to maximum recursive depth exceeded. Therefore, it's never converged to the goal. \n",
    "\n",
    "# Conclusions\n",
    "After looking at both BFS AND DFS, I find BFS is much faster in our problem. "
   ]
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "name": "ai_project1_code.ipynb",
   "provenance": [],
   "version": "0.3.2"
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
